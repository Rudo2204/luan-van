\chapter{Cơ sở lý thuyết}\label{ch2-top}
\section{Một số vấn đề về ngôn ngữ lập trình}
Trước hết, cần khẳng định một điều là mọi ngôn ngữ lập trình, xét về chức năng thì đều có thể xem là ngang bằng nhau.
Điều này còn được gọi là Turing compatible.

All computing languages or computers can compute anything in theory but nothing of practical interest is easy.

Vì vậy, tuy rằng mọi vấn đề trong thực tế tuy rằng trên lý thuyết đều có thể tính toán được bằng bất cứ ngôn ngữ lập trình nào.
Tuy nhiên dựa trên cấu trúc và thiết kế của một ngôn ngữ lập trình thì quá trình giải quyết này có thể sẽ gặp nhiều bất lợi, hay thậm chí là tốn quá nhiều thời gian dẫn đến vấn đề không hoàn thành trước hạn chót, mang lại hiệu quả công việc thấp.

Để vượt qua vấn đề này thì điều phù hợp, logic nhất cần làm là thiết kế một ngôn ngữ lập trình phù hợp để giải quyết các vấn đề đó, và chỉ các vấn đề đó.
Cũng chính vì lý do này mà ngôn ngữ Rust khi được thiết kế cũng đã được cân nhắc kĩ lưỡng để giải quyết các vấn đề trong một lĩnh vực nhất định.
Chúng ta cần hiểu rõ những quyết định đưa ra của các nhà phát triển khi thiết kế một ngôn ngữ để có thể hiểu rõ được cách mã nguồn Rust được thực hiện như thế nào, cấu trúc ra sao, mà từ đó có thể đưa ra những nhận xét về ngôn ngữ Rust nói chung, cũng như có thể so sánh được Rust với các ngôn ngữ lập trình khác (mà trong lĩnh vực lập trình nhúng, thì chủ đạo sẽ là so sánh ngôn ngữ Rust với ngôn ngữ C).
Trong các chương sau, một số ý tưởng ``mới'' của ngôn ngữ Rust như ownership (quyền sở hữu), mutability (khả năng chỉnh sửa, biến đổi) hay borrowing lifetimes (vay mượn thời gian sống) cũng sẽ được giới thiệu.
Sau đấy là một số quyết định cốt lõi trong việc thiết kế ngôn ngữ Rust mà các nhà phát triển ở tập đoàn Mozzila đã lựa chọn khi thiết kế ngôn ngữ Rust.
\subsection{Mục tiêu thiết kế của một ngôn ngữ}
Mục tiêu thiết kế của ngôn ngữ Rust, theo như FAQ của website chính thức của ngôn ngữ Rust được viết như sau:
\bigskip

To design and implement a safe, concurrent, practical systems language.

Rust exists because other languages at this level of abstraction and efficiency are unsatisfactory. In particular:

\begin{enumerate}
\item There is too little attention paid to safety.
\item They have poor concurrency support.
\item There is a lack of practical affordances.
\item They offer limited control over resources.
\end{enumerate}

Rust exists as an alternative that provides both efficient code and a comfortable level of abstraction, while improving on all four of these points.

\bigskip

Với những mục tiêu thiết kế cốt lõi trên, ngôn ngữ Rust đã được phát triển hoàn thiện và được phát hành vào năm 2015.
Ngôn ngữ Rust là một ngôn ngữ hệ thống an toàn, mã nguồn khi được dịch ra ngôn ngữ máy assembly có thể dự đoán được.
Ngôn ngữ Rust không sử dụng garbage collector (bộ thu dọn rác). Bộ nhớ được quản lý thủ công, và bộ compiler cam kết sẽ không xảy ra các lỗi về bộ nhớ như truy cập bộ nhớ sau khi đã giải phóng, giải phóng bộ nhớ nhiều lần dẫn đến thất thoát dữ liệu, v.v..
Biên dịch được mã nguồn thành ngôn ngữ máy và không sử dụng garbage collector là một trong những tiêu chí rất quan trọng trong việc thiết kế một ngôn ngữ lập trình hệ thống, đặc biệt là cho việc sử dụng trong lập trình nhúng.
Để giải thích cho vấn đề này thì có thể hiểu rằng, các ngôn ngữ sử dụng garbage collector khi biên dịch rất khó dự đoán trước được mã máy assembly, vì ngoài phần mã máy được biên dịch từ chương trình chính thì còn các mã máy khác được biên dịch cho việc quản lý bộ nhớ cho chương trình.
Điều này dẫn đến việc sử dụng các ngôn ngữ này không phù hợp cho việc thiết kế hệ thống nhúng, ví như một hệ điều hành, khi mà nó cần độ chính xác cao để sử lý ngắt và các tác vụ thời gian thực.

Ngôn ngữ C là ngôn ngữ hệ thống được sử dụng rộng rãi nhất hiện nay. Một trong những ưu điểm lớn nhất của ngôn ngữ C cũng đi từ một trong những mục tiêu thiết ban đầu của ngôn ngữ C đó là thiết kế một assembler có tính portable cao, cũng vì lý do này mà khi lập trình ngôn ngữ C, người lập trình có thể truy cập trực đến đến từng địa chỉ, từng vùng nhớ, v.v.. Tính an toàn không nằm trong những mục tiêu thiết kế ban đầu của ngôn ngữ C, nó được giao lại cho người lập trình quản lý. Tuy rằng, trên lý thuyết điều này không làm ảnh hưởng đến tính an toàn của hệ thống, tuy nhiên con người thường hay mắt những sai lầm, có thể là vô ý hay cố ý, mà từ đó dẫn đến nhiều hệ lụy không mong muốn, có thể gây thiệt hại lớn đến hệ thống, ảnh hưởng đến rất nhiều người khác cũng sử dụng hệ thống đó.

Ngày nay ta có thể tìm thấy rất nhiều lỗi bảo mật liên quan đến các vấn đề về tính an toàn của một ngôn ngữ như buffer overflow/underflow, double free, race condition, v.v.. Tất cả những lỗi bảo mật này đều có một điểm chung đó là chúng đều liên quan đến vấn đề về bộ nhớ. Vấn đề này, ở cốt lõi, xảy ra vì con người thường bỏ qua những edge case hiếm gặp, đây không phải là một lỗi của ngôn ngữ được sử dụng. Các ngôn ngữ mà thường quản lý và kiểm tra những edge case này thường là các ngôn ngữ cấp cao, sử dụng garbage collector. Chính vì điều này mà ngôn ngữ Rust được tạo ra để giải quyết vấn đề nan giải này, với mục tiêu trở thành một ngôn ngữ vừa an toàn mà lại vừa có thể được gọi là một ngôn ngữ cấp thấp, và vẫn giữ được tốc độ và tuân theo nguyên tắc ``zero overhead''.

Bjarne Stroustrup giải thích về nguyên tắt ``zero overhead'' trong bài viết về ngôn ngữ C++ của ông như sau: ``In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.''

\subsection{Undefined behavior}
Một trong những vấn đề phổ biến có thể gặp khi lập trình sử dụng ngôn ngữ C/C++ đó là ``undefined behavior''. Trong \emph{The Current C Programming Language Standard – ISO/IEC 9899:2018 (C18)}, undefined behavior được định nghĩa như sau:

\bigskip
 3.4.3\par
 undefined behavior:\par
 behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for whichthis document imposes no requirements
\bigskip

Trong thực tế, một trong những hiệu ứng sau (nhưng không chỉ những hiệu ứng đã liệt kê sau) có thể xảy ra khi một chương trình có undefined behavior xảy ra:

\begin{enumerate}
    \item Không xảy ra vấn đề, chương trình chạy đúng.
    \item Không có hiệu ứng gì.
    \item Chương trình chạy một cách ngẫu nhiên.
    \item Chương trình gặp phải lỗi và crash.
    \item Chương trình tiếp tục chạy và crash sau đó (có thể bất cứ lúc nào).
    \item Chương trình tiếp tục chạy nhưng kết quả cho ra không chính xác.
    \item Chương trình ghi đè các biến khác trong bộ nhớ.
    \item Chương trình trả về kết quả của hàm không đúng.
    \item Chương trình chạy ``ngẫu nhiên'' phụ thuộc vào data nhận vào.
\end{enumerate}

Trong những vấn đề có thể xảy ra như đã liệt kê trên thì hiệu ứng được liệt kê cuối là một vấn đề nguy hiểm nhất đối với bảo mật hệ thống.
Một người tấn công hệ thống có thể thiết kế data nhận vào hệ thống để có thể điều khiển chương trình chạy theo cách họ muốn.

Một chương trình không thể xảy ra undefined behavior ở bất kì tình huống nào được gọi là ``well defined''.
Để chương trình không xả ra undefined behavior thì trong ngôn ngữ C/C++ người lập trình phải nắm rõ các edge cases có thể xảy ra undefined behavior, từ đó mà viết mã nguồn để tránh các trường hợp này.
Tuy nhiên như đã thảo luận ở phần trước, con người rất hay bỏ qua các trường hợp edge case hiếm gặp.
Để giải quyết vấn đề này, ngôn ngữ Rust được thiết kế với yêu cầu an toàn nên toàn bộ chương viết sử dụng ngôn ngữ Rust luôn luôn là một chương trình well defined, trừ khi người lập trình sử dụng từ khóa \emph{unsafe}, vấn đề này sẽ được trình bày ở các phần sau.

%Undefined behavior có một ưu điểm giúp mã nguồn có thể được tối ưu hóa một cách dễ dàng hơn.
%Khi xảy ra undefined behavior, bộ compiler sẽ chọn cách tối ưu hóa tốt nhất.
%Chúng ta có thể xem một ví dụ về undefined behavior trong ví dụ mã nguồn sau:
%#include <stdio.h>
%int main(int argc, char *argv[]) {
%    int a = 0;
%    if (argc == 1) {
%        a = 2147483647;
%    }
%
%    printf("a = %i\n", a);
%    if (a + a < 0) {
%        printf("Overflow.\n");
%    } else {
%        printf("No overflow.\n");
%    }
%}

\subsection{An toàn kiểu}
Type safety (an toàn kiểu) là một trong những thuộc tính mà một chương trình well defined luôn có. Type safety đảm bảo một biến không được hiểu ngầm sai về kiểu của nó, type safety cũng giúp bảo hệ về vấn đề bảo mật bộ nhớ, vì khi chương trình không hiểu ngầm sai về kiểu của một biến thì sẽ không xảy ra hiện tượng copy, chỉnh sửa, v.v.. sai, dẫn đến undefined behavior.

Phần lớn ngôn ngữ có đảm bảo tính an toàn về kiểu, điển hình như Python, Java hay JavaScipt, v.v.. thì hầu hết đều sử dụng garbage collector, dẫn đến vấn đề khó sử dụng trong môi trường lập trình cấp thấp hay trong các môi trường hạn chế về bộ nhớ như vi điều khiển như đã thảo luận ở trên.

Ngôn ngữ C và C++ là một trong số ít ngôn ngữ phổ biến hiện hay không đảm bảo tính an toàn về kiểu, điều này lại một lần nữa giao lại cho người lập trình thủ công nhận biết và phát triển hệ thống tránh gặp phải các trường hợp này.
Tuy phần lớn các vấn đề có thể xảy ra khi một hệ thống được viết bởi ngôn ngữ C, C++ không đảm bảo về tính an toàn, và thường là nằm ngoài mong muốn của người phát triển hệ thống thì cũng có thể người lập trình lại muốn sử dụng tính không an toàn này để điều khiển driver cho phần cứng, viết vào các vùng nhớ hoặc chạy intruction một cách kéo léo để điều khiển hệ thống chạy đúng với mong muốn với người lập trình.
Tính an toàn về kiểu có thể sẽ làm cho những công việc trên rất khó hoặc hoàn toàn không thể thực hiện được.

Xét về type safety thì mọi chương trình viết bằng ngôn ngữ Rust đều đảm bảo về tính an toàn kiểu. Tuy nhiên, nếu người lập trình muốn thực hiện những thao tác không an toàn như đã liệt kệ trên thì điều đó là hoàn toàn có thể thực hiện được bằng cách sử dụng từ khóa \emph{unsafe}.
Mã nguồn trong khối unsafe có thể được sử dụng để làm bất kì điều gì, và khi biên dịch thì bộ compiler sẽ bỏ qua kiểm tra tính an toàn trong các khối này.
Nếu sử dụng không đúng cách thì các khối unsafe này có thể dẫn đến undefined behavior trong một chương trình viết bởi ngôn ngữ Rust, tuy nhiên không thể phủ nhận được tính hữu dụng cho người phát triển hệ thống để có thể bỏ qua một số kiểm tra an toàn của hệ thống để có thể điều khiển nó theo ý muốn của mình.

\subsection{Quản lý bộ nhớ}
Về quản lý bộ nhớ, ngôn ngữ Rust sử dụng mô hình RAII (Resource Accquistion Is Initialization) hay còn biết tới một tên khác là SBRM (Scope-Bound Resource Management).
Khái niệm này có thể hiểu là các tài nguyên sẽ được giải phóng ngược lại với thứ tự nó nhận vào, và được thực hiện một cách tự động khi một hàm hay một method trả về, điều này phải thực hiện ngay cả khi gặp phải lỗi trong quá trình này.
Điều này giúp đảm bảo không bị rò rỉ tài nguyên hệ thống (resource leak), các tài nguyên này luôn được giữ trong quá trình nhận được tài nguyên này cho đến khi giải phóng. Vì vậy, nếu không có tài nguyên bị rò rỉ thì sẽ không bị rò rỉ bộ nhớ.
%\subsection{Các nền tảng được hỗ trợ}
%\subsection{Từ khóa}
%Ở thời điểm bài viết, ngôn ngữ Rust có tổng cộng 39 từ khóa so với C89 với 35 từ khóa.
%Ngoài ra Rust còn dự trữ trước 13 từ khóa khác với mục đích thêm các tính năng mới cho ngôn ngữ Rust trong tương lai (https://doc.rust-lang.org/reference/keywords.html#reserved-keywords).
%Trong những từ khóa dữ trữ trước này thì từ khóa \emph{box} và \emph{macro} đã có thể được sử dụng, tuy nhiên được các nhà phát triển đánh giá là không ổn định (unstable) TODO: https://github.com/rust-lang/rust/issues/39412 https://github.com/rust-lang/rust/issues/49733

\section{Đánh giá một ngôn ngữ lập trình}
Đánh giá một ngôn ngữ lập trình, trên mọi khía cạnh là một công việc không hề dễ dàng, và bài luận văn này cũng không tập trung vào khía cạnh đánh giá toàn vẹn một ngôn ngữ lập trình, trong bài luận văn này là đánh giá về ngôn ngữ lập trình Rust mà sẽ chỉ đưa ra một số tài liệu, số liệu, đánh giá đã được nghiên cứu trong các bài báo, tài liệu khác.
Các tài liệu, số liệu, đánh giá này được đưa ra với mong muốn tập trung vào khía cạnh sử dụng ngôn ngữ Rust trong môi trường thực tế, đưa dần mã nguồn viết sử dụng ngôn ngữ Rust dần vào codebase, tích hợp sử dụng chung với mã nguồn C/C++ có sẵnm v.v..

Một trong những vấn đề chính sẽ được thảo luận sẽ là các vấn đề về bảo mật an toàn, cả về các lỗi có thể xảy ra trong các ngôn ngữ không an toàn khác cũng như là các vấn đề về race condition hay tương tự trong mảng lập trình concurrent mà ngôn ngữ Rust đã giải quyết; một số vấn đề về thư viện chuẩn của Rust (standard library), cũng như môi trường không có thư viện chuẩn này để có thể lập trình trong mảng lập trình nhúng; một phần khác cũng sẽ được thảo luận là tích hợp ngôn ngữ Rust với các thư viện hay mã nguồn C có sẵn trong codebase để tiết kiệm thời gian, không phải viết lại toàn bộ codebase mà vẫn sử dụng được các tính năng mà ngôn ngữ Rust mang lại; và trong các phần này, một số nhược điểm khi sử dụng Rust so với các ngôn ngữ khác (chủ yếu ở đây là so sánh với ngôn ngữ C) cũng sẽ được đưa ra.

Cũng trong phần đánh giá, một số vấn đề khác về phát triển một hệ thống sử dụng ngôn ngữ lập trình nói chung và ngôn ngữ Rust nói riêng cũng được đánh giá, đó là:

\begin{enumerate}
    \item Linking và Building: nếu một ngôn ngữ có vấn đề trong khâu linking, building sẽ dẫn tới các vấn đề trong quá trình  phát triển hệ thống, dẫn đến việc không phù hợp trong việc kiểm tra hệ thống hay chạy thực tế. Cũng trong phần này, vấn đề tích hợp với ngôn ngữ C, sử dụng hai thư viện Glib hay D-Bus cũng được thảo luận.

    \item Debugging: debugging là một khâu quan trọng trong phát triển hệ thống để tìm các lỗi về logic hay bộ nhớ có thể phát sinh trong quá trình viết mã nguồn.
Nếu hệ thống debugging của một ngôn ngữ được hỗ trợ quá kém hay không đủ mạnh có thể dẫn đến sự trễ nãi trong quá trình phát triển hệ thống hay mang lại hiệu quả công việc thấp.

    \item Testing, thời gian phiên dịch, các vấn đề về tài liệu, IDE và một số vấn đề khác cũng được đề cập qua.
\end{enumerate}

Ngoài ra còn có nhiều vấn đề kỹ thuật khác trong lĩnh vực lập trình nhúng cần được thảo luận như các hệ thống hệ điều hành thời gian thực RTOS, sử dụng ngôn ngữ Rust trong các thiết bị trong mức hỗ trợ thấp (tier 3 support) hay các design pattern, language design, v.v..
Tuy nhiên, với mục đích chính của đề tài là nghiên cứu ngôn ngữ Rust nhằm nâng cao nhận thức về cách sử dụng một ngôn ngữ tiềm năng mới này và phân tích thực hiện một hệ thống thực tế sử dụng ngôn ngữ Rust nên các vấn đề này sẽ được bỏ qua.

Như đã liệt kê trên là những vấn đề chính khi thảo luận phân tích về một ngôn ngữ lập trình, nhưng cũng có thể sẽ có những vấn đề không lường trước xảy ra trong quá trình phát triển hệ thống.
Khi gặp phải những vấn đề này thì cách giải quyết tốt nhất đó chính là liên hệ, thảo luận với cộng đồng sử dụng ngôn ngữ Rust để tìm ra cách giải quyết tốt nhất.
Vì vậy, vấn đề về cộng đồng sử dụng ngôn ngữ Rust nói chung cũng sẽ được thảo luận qua, cũng như hướng phát triển của ngôn ngữ Rust.

\section{Các khía cạnh đánh giá}
Để đánh giá các khía cạnh của một ngôn ngữ lập trình đã nêu trên thì ở phần này tôi đưa ra một số câu hỏi thường hay được đặt ra để thảo luận về các vấn đề này. Những câu hỏi có thể được liên quan đến các vấn đề khác, nhưng sẽ được tập trung chính vào vấn đề đó.
\subsection{Ngôn ngữ lập trình Rust}
\begin{itemize}
    \item[--] Ngôn ngữ lập trình Rust có dễ học không, tính logic của ngôn ngữ này như thế nào?
    \item[--] Có dễ để viết một chương trình sử dụng ngôn ngữ Rust không?
    \item[--] Cấu trúc của ngôn ngữ Rust hỗ trợ người phát triển đến đâu?
    \item[--] Ngôn ngữ Rust được duy trì và phát triển như thế nào?
    \item[--] Các vấn đề về giấy tờ hợp pháp khi sử dụng ngôn ngữ Rust.
\end{itemize}

\subsection{Linking, Building và Compiling}
\begin{itemize}
    \item[--]Compiler khi gặp lỗi sẽ đưa ra lỗi gì, những lỗi này có giúp người phát triển nhanh chóng sữa lỗi không?
    \item[--]Hệ thống Linking/Building chính thức của Rust là Cargo có dễ sử dụng không?
    \item[--]Các mức hỗ trợ của bộ compiler là gì? Các mức hỗ trợ có ảnh hưởng như thế nào tới việc dịch mã trong quá trình phát triển?
    \item[--]Những vấn đề thông thường gặp phải khi tích hợp Rust với ngôn ngữ C là gì? Liệu việc tích hợp này có dễ dàng không?
    \item[--]Khi tích hợp thành công thì quá trình linking, building và compiling này khác gì so với chỉ sử dụng hệ thống chính thức của Rust là Cargo?
\end{itemize}

\subsection{Các công cụ phát triển}
\begin{itemize}
    \item[--] Bộ Debugger được hỗ trợ chính trong một chương trình viết sử dụng ngôn ngữ Rust là gì?
    \item[--] Các vấn đề về testing, CI/CD trong một hệ thống sử dụng ngôn ngữ Rust như thế nào?
    \item[--] IDE cho Rust hiện tại như thế nào?
\end{itemize}

\subsection{Yếu tố chất lượng}
Để đánh giá một chương trình, hệ thống thì có thể được chia thành rất nhiều yếu tố khác nhau.
Theo như ISO/IEC 25010:2011 thì có một số yếu tố chính như sau: functional sustainability, reliability, performance efficiency, operationality, security, compability, maintainability và transferbility. Các hạng mục này được chia thành 31 hạng mục nhỏ hơn.
Để đánh giá chính xác một hệ thống theo như chuẩn trên là một vấn đề kỹ thuật khó khăn và vượt ngoài tầm của đề tài này.
Tuy nhiên để đánh giá chung về chất lượng của hệ thống thì tôi sẽ dưa trên chuẩn trên để từ đó đặt ra một số câu hỏi để từ đó thảo luận về chất lượng của hệ thống này trong các chương sau.
\begin{itemize}
    \item[--] Mã nguồn Rust có dễ duy trì ồn định không?
    \item[--] Hiệu suất của chương trình viết sử dụng Rust so với ngôn ngữ khác, ở đây chủ yếu so sánh với C như thế nào?
    \item[--] Chương trình viết sử dụng ngôn ngữ Rust an toàn hơn so với ngôn ngữ C ở những điểm nào?
    \item[--] Mã nguồn Rust có tính portability cao hay không?
    \item[--] Mã nguồn Rust được viết sử dụng tích hợp khi sử dụng với các thư viện C/C++ có sẵn như thế nào?
\end{itemize}
