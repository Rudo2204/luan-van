\chapter{Cơ sở lý thuyết}\label{ch2-top}
\section{Một số vấn đề về ngôn ngữ lập trình}
Trước hết, cần khẳng định một điều là mọi ngôn ngữ lập trình, xét về chức năng thì đều có thể xem là ngang bằng nhau.
Điều này còn được gọi là Turing compatible.

All computing languages or computers can compute anything in theory but nothing of practical interest is easy.

Vì vậy, tuy rằng mọi vấn đề trong thực tế tuy rằng trên lý thuyết đều có thể tính toán được bằng bất cứ ngôn ngữ lập trình nào.
Tuy nhiên dựa trên cấu trúc và thiết kế của một ngôn ngữ lập trình thì quá trình giải quyết này có thể sẽ gặp nhiều bất lợi, hay thậm chí là tốn quá nhiều thời gian dẫn đến vấn đề không hoàn thành trước hạn chót, mang lại hiệu quả công việc thấp.

Để vượt qua vấn đề này thì điều phù hợp, logic nhất cần làm là thiết kế một ngôn ngữ lập trình phù hợp để giải quyết các vấn đề đó, và chỉ các vấn đề đó.
Cũng chính vì lý do này mà ngôn ngữ Rust khi được thiết kế cũng đã được cân nhắc kĩ lưỡng để giải quyết các vấn đề trong một lĩnh vực nhất định.
Chúng ta cần hiểu rõ những quyết định đưa ra của các nhà phát triển khi thiết kế một ngôn ngữ để có thể hiểu rõ được cách mã nguồn Rust được thực hiện như thế nào, cấu trúc ra sao, mà từ đó có thể đưa ra những nhận xét về ngôn ngữ Rust nói chung, cũng như có thể so sánh được Rust với các ngôn ngữ lập trình khác (mà trong lĩnh vực lập trình nhúng, thì chủ đạo sẽ là so sánh ngôn ngữ Rust với ngôn ngữ C).
Trong các chương sau, một số ý tưởng ``mới'' của ngôn ngữ Rust như ownership (quyền sở hữu), mutability (khả năng chỉnh sửa, biến đổi) hay borrowing lifetimes (vay mượn thời gian sống) cũng sẽ được giới thiệu.
Sau đấy là một số quyết định cốt lõi trong việc thiết kế ngôn ngữ Rust mà các nhà phát triển ở tập đoàn Mozzila đã lựa chọn khi thiết kế ngôn ngữ Rust.
\subsection{Mục tiêu thiết kế của một ngôn ngữ}
Mục tiêu thiết kế của ngôn ngữ Rust, theo như FAQ của website chính thức của ngôn ngữ Rust được viết như sau:
\bigskip

To design and implement a safe, concurrent, practical systems language.

Rust exists because other languages at this level of abstraction and efficiency are unsatisfactory. In particular:

\begin{enumerate}
\item There is too little attention paid to safety.
\item They have poor concurrency support.
\item There is a lack of practical affordances.
\item They offer limited control over resources.
\end{enumerate}

Rust exists as an alternative that provides both efficient code and a comfortable level of abstraction, while improving on all four of these points.

\bigskip

Với những mục tiêu thiết kế cốt lõi trên, ngôn ngữ Rust đã được phát triển hoàn thiện và được phát hành vào năm 2015.
Ngôn ngữ Rust là một ngôn ngữ hệ thống an toàn, mã nguồn khi được dịch ra ngôn ngữ máy assembly có thể dự đoán được.
Ngôn ngữ Rust không sử dụng garbage collector (bộ thu dọn rác). Bộ nhớ được quản lý thủ công, và bộ compiler cam kết sẽ không xảy ra các lỗi về bộ nhớ như truy cập bộ nhớ sau khi đã giải phóng, giải phóng bộ nhớ nhiều lần dẫn đến thất thoát dữ liệu, v.v..
Biên dịch được mã nguồn thành ngôn ngữ máy và không sử dụng garbage collector là một trong những tiêu chí rất quan trọng trong việc thiết kế một ngôn ngữ lập trình hệ thống, đặc biệt là cho việc sử dụng trong lập trình nhúng.
Để giải thích cho vấn đề này thì có thể hiểu rằng, các ngôn ngữ sử dụng garbage collector khi biên dịch rất khó dự đoán trước được mã máy assembly, vì ngoài phần mã máy được biên dịch từ chương trình chính thì còn các mã máy khác được biên dịch cho việc quản lý bộ nhớ cho chương trình.
Điều này dẫn đến việc sử dụng các ngôn ngữ này không phù hợp cho việc thiết kế hệ thống nhúng, ví như một hệ điều hành, khi mà nó cần độ chính xác cao để sử lý ngắt và các tác vụ thời gian thực.

Ngôn ngữ C là ngôn ngữ hệ thống được sử dụng rộng rãi nhất hiện nay. Một trong những ưu điểm lớn nhất của ngôn ngữ C cũng đi từ một trong những mục tiêu thiết ban đầu của ngôn ngữ C đó là thiết kế một assembler có tính portable cao, cũng vì lý do này mà khi lập trình ngôn ngữ C, người lập trình có thể truy cập trực đến đến từng địa chỉ, từng vùng nhớ, v.v.. Tính an toàn không nằm trong những mục tiêu thiết kế ban đầu của ngôn ngữ C, nó được giao lại cho người lập trình quản lý. Tuy rằng, trên lý thuyết điều này không làm ảnh hưởng đến tính an toàn của hệ thống, tuy nhiên con người thường hay mắt những sai lầm, có thể là vô ý hay cố ý, mà từ đó dẫn đến nhiều hệ lụy không mong muốn, có thể gây thiệt hại lớn đến hệ thống, ảnh hưởng đến rất nhiều người khác cũng sử dụng hệ thống đó.

Ngày nay ta có thể tìm thấy rất nhiều lỗi bảo mật liên quan đến các vấn đề về tính an toàn của một ngôn ngữ như buffer overflow/underflow, double free, race condition, v.v.. Tất cả những lỗi bảo mật này đều có một điểm chung đó là chúng đều liên quan đến vấn đề về bộ nhớ. Vấn đề này, ở cốt lõi, xảy ra vì con người thường bỏ qua những edge case hiếm gặp, đây không phải là một lỗi của ngôn ngữ được sử dụng. Các ngôn ngữ mà thường quản lý và kiểm tra những edge case này thường là các ngôn ngữ cấp cao, sử dụng garbage collector. Chính vì điều này mà ngôn ngữ Rust được tạo ra để giải quyết vấn đề nan giải này, với mục tiêu trở thành một ngôn ngữ vừa an toàn mà lại vừa có thể được gọi là một ngôn ngữ cấp thấp, và vẫn giữ được tốc độ và tuân theo nguyên tắc ``zero overhead''.

Bjarne Stroustrup giải thích về nguyên tắt ``zero overhead'' trong bài viết về ngôn ngữ C++ của ông như sau: ``In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.''

\subsection{Undefined behavior}
Một trong những vấn đề phổ biến có thể gặp khi lập trình sử dụng ngôn ngữ C/C++ đó là ``undefined behavior''. Trong \emph{The Current C Programming Language Standard – ISO/IEC 9899:2018 (C18)}, undefined behavior được định nghĩa như sau:

\bigskip
 3.4.3\par
 undefined behavior:\par
 behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for whichthis document imposes no requirements
\bigskip

Trong thực tế, một trong những hiệu ứng sau (nhưng không chỉ những hiệu ứng đã liệt kê sau) có thể xảy ra khi một chương trình có undefined behavior xảy ra:

\begin{enumerate}
    \item Không xảy ra vấn đề, chương trình chạy đúng.
    \item Không có hiệu ứng gì.
    \item Chương trình chạy một cách ngẫu nhiên.
    \item Chương trình gặp phải lỗi và crash.
    \item Chương trình tiếp tục chạy và crash sau đó (có thể bất cứ lúc nào).
    \item Chương trình tiếp tục chạy nhưng kết quả cho ra không chính xác.
    \item Chương trình ghi đè các biến khác trong bộ nhớ.
    \item Chương trình trả về kết quả của hàm không đúng.
    \item Chương trình chạy ``ngẫu nhiên'' phụ thuộc vào data nhận vào.
\end{enumerate}

Trong những vấn đề có thể xảy ra như đã liệt kê trên thì hiệu ứng được liệt kê cuối là một vấn đề nguy hiểm nhất đối với bảo mật hệ thống.
Một người tấn công hệ thống có thể thiết kế data nhận vào hệ thống để có thể điều khiển chương trình chạy theo cách họ muốn.

Một chương trình không thể xảy ra undefined behavior ở bất kì tình huống nào được gọi là ``well defined''.
Để chương trình không xả ra undefined behavior thì trong ngôn ngữ C/C++ người lập trình phải nắm rõ các edge cases có thể xảy ra undefined behavior, từ đó mà viết mã nguồn để tránh các trường hợp này.
Tuy nhiên như đã thảo luận ở phần trước, con người rất hay bỏ qua các trường hợp edge case hiếm gặp.
Để giải quyết vấn đề này, ngôn ngữ Rust được thiết kế với yêu cầu an toàn nên toàn bộ chương viết sử dụng ngôn ngữ Rust luôn luôn là một chương trình well defined, trừ khi người lập trình sử dụng từ khóa \emph{unsafe}, vấn đề này sẽ được trình bày ở các phần sau.

%Undefined behavior có một ưu điểm giúp mã nguồn có thể được tối ưu hóa một cách dễ dàng hơn.
%Khi xảy ra undefined behavior, bộ compiler sẽ chọn cách tối ưu hóa tốt nhất.
%Chúng ta có thể xem một ví dụ về undefined behavior trong ví dụ mã nguồn sau:
%#include <stdio.h>
%int main(int argc, char *argv[]) {
%    int a = 0;
%    if (argc == 1) {
%        a = 2147483647;
%    }
%
%    printf("a = %i\n", a);
%    if (a + a < 0) {
%        printf("Overflow.\n");
%    } else {
%        printf("No overflow.\n");
%    }
%}

\subsection{An toàn kiểu}
Type safety (an toàn kiểu) là một trong những thuộc tính mà một chương trình well defined luôn có. Type safety đảm bảo một biến không được hiểu ngầm sai về kiểu của nó, type safety cũng giúp bảo hệ về vấn đề bảo mật bộ nhớ, vì khi chương trình không hiểu ngầm sai về kiểu của một biến thì sẽ không xảy ra hiện tượng copy, chỉnh sửa, v.v.. sai, dẫn đến undefined behavior.

Phần lớn ngôn ngữ có đảm bảo tính an toàn về kiểu, điển hình như Python, Java hay JavaScipt, v.v.. thì hầu hết đều sử dụng garbage collector, dẫn đến vấn đề khó sử dụng trong môi trường lập trình cấp thấp hay trong các môi trường hạn chế về bộ nhớ như vi điều khiển như đã thảo luận ở trên.

Ngôn ngữ C và C++ là một trong số ít ngôn ngữ phổ biến hiện hay không đảm bảo tính an toàn về kiểu, điều này lại một lần nữa giao lại cho người lập trình thủ công nhận biết và phát triển hệ thống tránh gặp phải các trường hợp này.
Tuy phần lớn các vấn đề có thể xảy ra khi một hệ thống được viết bởi ngôn ngữ C, C++ không đảm bảo về tính an toàn, và thường là nằm ngoài mong muốn của người phát triển hệ thống thì cũng có thể người lập trình lại muốn sử dụng tính không an toàn này để điều khiển driver cho phần cứng, viết vào các vùng nhớ hoặc chạy intruction một cách kéo léo để điều khiển hệ thống chạy đúng với mong muốn với người lập trình.
Tính an toàn về kiểu có thể sẽ làm cho những công việc trên rất khó hoặc hoàn toàn không thể thực hiện được.

Xét về type safety thì mọi chương trình viết bằng ngôn ngữ Rust đều đảm bảo về tính an toàn kiểu. Tuy nhiên, nếu người lập trình muốn thực hiện những thao tác không an toàn như đã liệt kệ trên thì điều đó là hoàn toàn có thể thực hiện được bằng cách sử dụng từ khóa \emph{unsafe}.
Mã nguồn trong khối unsafe có thể được sử dụng để làm bất kì điều gì, và khi biên dịch thì bộ compiler sẽ bỏ qua kiểm tra tính an toàn trong các khối này.
Nếu sử dụng không đúng cách thì các khối unsafe này có thể dẫn đến undefined behavior trong một chương trình viết bởi ngôn ngữ Rust, tuy nhiên không thể phủ nhận được tính hữu dụng cho người phát triển hệ thống để có thể bỏ qua một số kiểm tra an toàn của hệ thống để có thể điều khiển nó theo ý muốn của mình.

\subsection{Quản lý bộ nhớ}
Về quản lý bộ nhớ, ngôn ngữ Rust sử dụng mô hình RAII (Resource Accquistion Is Initialization) hay còn biết tới một tên khác là SBRM (Scope-Bound Resource Management).
Khái niệm này có thể hiểu là các tài nguyên sẽ được giải phóng ngược lại với thứ tự nó nhận vào, và được thực hiện một cách tự động khi một hàm hay một method trả về, điều này phải thực hiện ngay cả khi gặp phải lỗi trong quá trình này.
Điều này giúp đảm bảo không bị rò rỉ tài nguyên hệ thống (resource leak), các tài nguyên này luôn được giữ trong quá trình nhận được tài nguyên này cho đến khi giải phóng. Vì vậy, nếu không có tài nguyên bị rò rỉ thì sẽ không bị rò rỉ bộ nhớ.
%\subsection{Các nền tảng được hỗ trợ}
%\subsection{Từ khóa}
%Ở thời điểm bài viết, ngôn ngữ Rust có tổng cộng 39 từ khóa so với C89 với 35 từ khóa.
%Ngoài ra Rust còn dự trữ trước 13 từ khóa khác với mục đích thêm các tính năng mới cho ngôn ngữ Rust trong tương lai (https://doc.rust-lang.org/reference/keywords.html#reserved-keywords).
%Trong những từ khóa dữ trữ trước này thì từ khóa \emph{box} và \emph{macro} đã có thể được sử dụng, tuy nhiên được các nhà phát triển đánh giá là không ổn định (unstable) TODO: https://github.com/rust-lang/rust/issues/39412 https://github.com/rust-lang/rust/issues/49733

\section{Đánh giá một ngôn ngữ lập trình}
Đánh giá một ngôn ngữ lập trình, trên mọi khía cạnh là một công việc không hề dễ dàng, và bài luận văn này cũng không tập trung vào khía cạnh đánh giá toàn vẹn một ngôn ngữ lập trình, trong bài luận văn này là đánh giá về ngôn ngữ lập trình Rust mà sẽ chỉ đưa ra một số tài liệu, số liệu, đánh giá đã được nghiên cứu trong các bài báo, tài liệu khác.
Các tài liệu, số liệu, đánh giá này được đưa ra với mong muốn tập trung vào khía cạnh sử dụng ngôn ngữ Rust trong môi trường thực tế, đưa dần mã nguồn viết sử dụng ngôn ngữ Rust dần vào codebase, tích hợp sử dụng chung với mã nguồn C/C++ có sẵnm v.v..

Một trong những vấn đề chính sẽ được thảo luận sẽ là các vấn đề về bảo mật an toàn, cả về các lỗi có thể xảy ra trong các ngôn ngữ không an toàn khác cũng như là các vấn đề về race condition hay tương tự trong mảng lập trình concurrent mà ngôn ngữ Rust đã giải quyết; một số vấn đề về thư viện chuẩn của Rust (standard library), cũng như môi trường không có thư viện chuẩn này để có thể lập trình trong mảng lập trình nhúng; một phần khác cũng sẽ được thảo luận là tích hợp ngôn ngữ Rust với các thư viện hay mã nguồn C có sẵn trong codebase để tiết kiệm thời gian, không phải viết lại toàn bộ codebase mà vẫn sử dụng được các tính năng mà ngôn ngữ Rust mang lại; và trong các phần này, một số nhược điểm khi sử dụng Rust so với các ngôn ngữ khác (chủ yếu ở đây là so sánh với ngôn ngữ C) cũng sẽ được đưa ra.

Cũng trong phần đánh giá, một số vấn đề khác về phát triển một hệ thống sử dụng ngôn ngữ lập trình nói chung và ngôn ngữ Rust nói riêng cũng được đánh giá, đó là:

\begin{enumerate}
    \item Linking và Building: nếu một ngôn ngữ có vấn đề trong khâu linking, building sẽ dẫn tới các vấn đề trong quá trình  phát triển hệ thống, dẫn đến việc không phù hợp trong việc kiểm tra hệ thống hay chạy thực tế. Cũng trong phần này, vấn đề tích hợp với ngôn ngữ C, sử dụng hai thư viện Glib hay D-Bus cũng được thảo luận.

    \item Debugging: debugging là một khâu quan trọng trong phát triển hệ thống để tìm các lỗi về logic hay bộ nhớ có thể phát sinh trong quá trình viết mã nguồn.
Nếu hệ thống debugging của một ngôn ngữ được hỗ trợ quá kém hay không đủ mạnh có thể dẫn đến sự trễ nãi trong quá trình phát triển hệ thống hay mang lại hiệu quả công việc thấp.

    \item Testing, thời gian phiên dịch, các vấn đề về tài liệu, IDE và một số vấn đề khác cũng được đề cập qua.
\end{enumerate}

Ngoài ra còn có nhiều vấn đề kỹ thuật khác trong lĩnh vực lập trình nhúng cần được thảo luận như các hệ thống hệ điều hành thời gian thực RTOS, sử dụng ngôn ngữ Rust trong các thiết bị trong mức hỗ trợ thấp (tier 3 support) hay các design pattern, language design, v.v..
Tuy nhiên, với mục đích chính của đề tài là nghiên cứu ngôn ngữ Rust nhằm nâng cao nhận thức về cách sử dụng một ngôn ngữ tiềm năng mới này và phân tích thực hiện một hệ thống thực tế sử dụng ngôn ngữ Rust nên các vấn đề này sẽ được bỏ qua.

Như đã liệt kê trên là những vấn đề chính khi thảo luận phân tích về một ngôn ngữ lập trình, nhưng cũng có thể sẽ có những vấn đề không lường trước xảy ra trong quá trình phát triển hệ thống.
Khi gặp phải những vấn đề này thì cách giải quyết tốt nhất đó chính là liên hệ, thảo luận với cộng đồng sử dụng ngôn ngữ Rust để tìm ra cách giải quyết tốt nhất.
Vì vậy, vấn đề về cộng đồng sử dụng ngôn ngữ Rust nói chung cũng sẽ được thảo luận qua, cũng như hướng phát triển của ngôn ngữ Rust.

\section{Các khía cạnh đánh giá}
Để đánh giá các khía cạnh của một ngôn ngữ lập trình đã nêu trên thì ở phần này tôi đưa ra một số câu hỏi thường hay được đặt ra để thảo luận về các vấn đề này. Những câu hỏi có thể được liên quan đến các vấn đề khác, nhưng sẽ được tập trung chính vào vấn đề đó.
\subsection{Các tính năng về ngôn ngữ lập trình}
\begin{itemize}
    \item[--] Ngôn ngữ lập trình Rust có dễ học không, tính logic của ngôn ngữ này như thế nào?
    \item[--] Có dễ để viết một chương trình sử dụng ngôn ngữ Rust không?
    \item[--] Cấu trúc của ngôn ngữ Rust hỗ trợ người phát triển đến đâu?
    \item[--] Ngôn ngữ Rust được duy trì và phát triển như thế nào?
    \item[--] Các vấn đề về giấy tờ hợp pháp khi sử dụng ngôn ngữ Rust.
\end{itemize}

\subsection{Linking, Building và Compiling}
\begin{itemize}
    \item[--]Compiler khi gặp lỗi sẽ đưa ra lỗi gì, những lỗi này có giúp người phát triển nhanh chóng sữa lỗi không?
    \item[--]Hệ thống Linking/Building chính thức của Rust là Cargo có dễ sử dụng không?
    \item[--]Các mức hỗ trợ của bộ compiler là gì? Các mức hỗ trợ có ảnh hưởng như thế nào tới việc dịch mã trong quá trình phát triển?
    \item[--]Những vấn đề thông thường gặp phải khi tích hợp Rust với ngôn ngữ C là gì? Liệu việc tích hợp này có dễ dàng không?
    \item[--]Khi tích hợp thành công thì quá trình linking, building và compiling này khác gì so với chỉ sử dụng hệ thống chính thức của Rust là Cargo?
\end{itemize}

\subsection{Các công cụ phát triển}
\begin{itemize}
    \item[--] Bộ Debugger được hỗ trợ chính trong một chương trình viết sử dụng ngôn ngữ Rust là gì?
    \item[--] Các vấn đề về testing, CI/CD trong một hệ thống sử dụng ngôn ngữ Rust như thế nào?
    \item[--] IDE cho Rust hiện tại như thế nào?
\end{itemize}

\subsection{Yếu tố chất lượng}
Để đánh giá một chương trình, hệ thống thì có thể được chia thành rất nhiều yếu tố khác nhau.
Theo như ISO/IEC 25010:2011 thì có một số yếu tố chính như sau: functional sustainability, reliability, performance efficiency, operationality, security, compability, maintainability và transferbility. Các hạng mục này được chia thành 31 hạng mục nhỏ hơn.
Để đánh giá chính xác một hệ thống theo như chuẩn trên là một vấn đề kỹ thuật khó khăn và vượt ngoài tầm của đề tài này.
Tuy nhiên để đánh giá chung về chất lượng của hệ thống thì tôi sẽ dưa trên chuẩn trên để từ đó đặt ra một số câu hỏi để từ đó thảo luận về chất lượng của hệ thống này trong các chương sau.
\begin{itemize}
    \item[--] Mã nguồn Rust có dễ duy trì ồn định không?
    \item[--] Hiệu suất của chương trình viết sử dụng Rust so với ngôn ngữ khác, ở đây chủ yếu so sánh với C như thế nào?
    \item[--] Chương trình viết sử dụng ngôn ngữ Rust an toàn hơn so với ngôn ngữ C ở những điểm nào?
    \item[--] Mã nguồn Rust có tính portability cao hay không?
    \item[--] Mã nguồn Rust được viết sử dụng tích hợp khi sử dụng với các thư viện C/C++ có sẵn như thế nào?
\end{itemize}

\section{Lý thuyết cơ bản về ngôn ngữ Rust}
Phần này tôi sẽ đưa ra những lý thuyết cơ bản về ngôn ngữ Rust và những đặc điểm nổi bật của nó với mục tiêu giới thiệu sơ qua cho người đọc những lý thuyết chính sẽ được sử dụng để trình bày những phần sau trong đề tài này, cũng như trả lời một số câu hỏi về những khía cạnh sẽ được đánh giá đã nêu ra ở phần trên.
Tôi giả định trước người đọc đã ít nhiều biết về một số thuật ngữ lập trình được sử dụng phổ biến trong thực tế trong các ngôn ngữ như C/C++ hay Java, đặc biệt là trong lĩnh vực lập trình nhúng.
Những thuật ngữ ``mới'' được ngôn ngữ Rust đưa ra sử dụng sẽ được giới thiệu song song, so sánh với những ``cách làm cũ'' của các ngôn ngữ lập trình khác.

\subsection{Giới thiệu chính thức về Rust}
Trước khi đi vào phần giới thiệu các chứng năng nổi bật của ngôn ngữ Rust thì trước hết tôi xin giới thiệu một cách chính thức về ngôn ngữ lập trình này.
Ngôn ngữ Rust là một ngôn ngữ lập trình mã nguồn mở được phát triển và tài trợ bởi tập đoàn Mozilla.
Rust là một ngôn ngữ kiểu cố định (static type), đa mô hình (multi-paradigm).
Rust học hỏi từ rất nhiều ngôn ngữ ``đàn anh'' đi trước, một trong số những tính năng này sẽ được giới thiệu trong những phần sau.
Trong quá trình phát triển, ngôn ngữ Rust tập trung vào ba mục tiêu thiết kế chính là:
\begin{itemize}
\item Tính an toàn của hệ thống
\item Hiệu suất của hệ thống
\item Tính ổn định của hệ thống
\end{itemize}
Ngoài ba yêu tố chính trên thì Rust còn có rất nhiều mục tiêu thiết kế khác, tuy nhiên ngôn ngữ này sẽ luôn xoay quanh ba yếu tố trên nếu một trong những mục tiệu thiết kế kia không thể được triển khai đồng thời với ba mục tiêu này.

\subsection{Lý thuyết cơ bản}
Ở phần này, tôi bắt đầu giới thiệu các tính năng của Rust, đi từ thư viện chuẩn của ngôn ngữ, đến hệ thống kiểu, và những tính năng khác đồng thời cũng là một phần giới thiệu sơ qua về cú pháp, cấu trúc của một phần mềm viết sử dụng ngôn ngữ này.
Một trong số tính năng nay sẽ có ít nhiều trùng lặp với các ngôn ngữ sử dụng phổ biến trong mảng lập trình nhúng là ngôn ngữ C.
Tuy nhiên, vì Rust là một ngôn ngữ đa mô hình nên cấu trúc của ngôn ngữ Rust sẽ có nhiều tính năng ``mới'', ít gặp trong các hệ thống nhúng.
\subsubsection{Thư viện chuẩn của Rust}
Thư viện chuẩn của Rust (The Rust Standard Library -- RSL) là một thư viện được bao gồm trong tất cả các phần mềm Rust, nó là một abtraction layer để viết các phần mềm có tính portable cao.
Thư viện chuẩn này cung cấp những câu lệnh call đến thư viện hệ thống như \emph{alloc} (dành cho việc cấp bộ nhớ), \emph{collections} (dành cho cấu trúc dữ liệu cơ bản) và \emph{core} (sẽ được giới thiệu ở phần sau).
Tuy nhiên, thư viện này phụ thuộc vào hệ điều hành của hệ thống, vì vậy trong môi trường lập trình nhúng vi điều khiển khi mà mã nguồn chạy trực tiếp trên chip vi điều khiển thì thư viện này không thể sử dụng được.
Để giải quyết vấn đề này thì chúng ta có thể chọn cách không sử dụng RSL với các cú pháp \emph{no\_std}.

\subsubsection{Thư viện lõi của Rust}
Thư viện lõi của Rust (The Rust Core Library -- RCL) có chức năng liên kết những chức năng của ngôn ngữ đến các thư viện được sử dụng trong phần mềm.
RCL không tương tác trực tiếp với phần mềm Rust mà tương tác thông qua một giao diện được reexport bởi RSL.
Vì vậy, ta có thể điều chỉnh thư viện lõi này một cách dễ dàng mà giao diện trên sẽ vẫn được giữ nguyên.
Có thể hiểu cách khác là ta có thể dễ dàng điều chỉnh cách mà ngôn ngữ Rust tương tác với các thư viện được sử dụng trong một phần mềm Rust.
Điều này rất hữu dụng trong một môi trường lập trình nhúng khi mà thư viện chuẩn không thể sử dụng được, nhưng ta vẫn có thể sử dụng được ít nhiều thư viện lõi của Rust.

Bảng \ref{tbl:rust_primitive_type} liệt kê ra những loại dữ liệu cơ bản nhất của ngôn ngữ Rust.
Có thể thấy, ngoài những loại dữ liệu thường gặp trong ngôn ngữ C, Rust còn hỗ trợ một số kiểu dữ liệu khác như \emph{slices}, \emph{string} và \emph{tuples}.
RCL được sử dụng để định nghĩa cách sử dụng các loại dữ liệu này thông qua các thư viện khác của Rust.

\begin{longtable}{r|l}
\textbf{Kiểu} & \textbf{Mô tả} \\
\midrule
\endhead
bool & \emph{true} hoặc \emph{false} \\
char & Giá trị UTF-8 vô hướng (scalar) \\
f32, f64 & Số thực dấu phẩy động, độ chính xác đơn hay kép \\
u8, u16, u32, u64 & Số nguyên không dấu \\
i8, i16, i32, i64 & Số nguyên có dấu \\
isize, usize & Số nguyên chỉ độ rộng của trỏ \\
Pointer & Con trỏ thông thường (raw), không an toàn của C (*const T, *mut T) \\
Array & Mảng có độ rộng cố định, kí hiệu [T] \\
slice & Mọt phần nhỏ của mảng, kí hiệu \&[T] \\
str & Giá trị UTF-8 được mã hóa thành mảng byte \\
Tuple & List các phần tử, có giới hạn và đã được sắp xếp \\
\bottomrule
\caption{Các loại dữ liệu cơ bản của Rust}
\label{tbl:rust_primitive_type}
\end{longtable}
\subsubsection{Các kiểu biến và bindings của Rust}
Như đã liệt kê ở phần trên thì ngôn ngữ Rust hỗ trợ nhiều loại dữ liệu phổ biến, ta có thể sử dụng các loại dữ liệu này để gán vào các biến (\emph{variable}) sử dụng các \emph{binding} được cung cấp bởi RCL.
Từ khóa quan trọng nhất để thực hiện điều này chính là từ khóa \emph{let}.
Một biến trong phần mềm Rust có cấu trúc tương tự như các ngôn ngữ lập trình phổ biến hiện nay đó là bao gồm hai phần chính: tên và giá trị.
Tuy nhiên, so với ngôn ngữ C thì biến của Rust có một đặc điểm khác biệt đó là tính mutability (khả năng biến đổi) của biến đó.

Về mặc định, một biến của Rust không thể thay đổi giá trị.
Nếu người lập trình thay đổi những biến này trong quá trình chương trình thực thi thì bộ compiler sẽ báo lỗi lúc biên dịch chương trình.
Nếu muốn thay đổi giá trị của một biến, ta phải khai báo rõ ràng sử dụng từ khóa \emph{mut}.
Ví dụ \ref{code:rust_var_example} là một ví dụ cơ bản về cách gán giá trị cho một biến, và tính mutability của các biến này.

\begin{listing}
\begin{rustcode}
let x: i32 = 10; // gán giá trị 10 cho biến x (và gán loại dữ liệu là i32)
let mut y = 50; // gán giá trị 50 cho biến y (mặc định sẽ tự gán loại dữ liệu i32)
y = x; // biến y được thay đổi thành giá trị 10
x = y; // lỗi! vì mặc định biến x là không thay đổi nên không thể thay đổi giá trị
\end{rustcode}
\caption{Bindings cơ bản của các biến}
\label{code:rust_var_example}
\end{listing}

Như đã comment ở trong ví dụ thì mã Rust này khi biên dịch sẽ báo lỗi vì tính immutability của biến x.
Khác với ngôn ngữ C thì mọi biến đều có thể thay đổi được thì ở ví dụ chương trình Rust sẽ không biên dịch thành công, đây là một điều khá quan trọng mà người lập trình cần lưu ý.
Một điều thú vị khác trong ví dụ này là khả năng tự gán loại dữ liệu \emph{i32} cho biến \emph{y}.
Để giải thích cho điều này thì có thể hiểu rằng, ở trong ví dụ thì ở dòng thứ 3 ta có biến \emph{y} được gán bằng giá trị của biến \emph{x}, mà biến \emph{x} ở dòng 1 đã được định nghĩa là một biến \emph{i32}.
Vì vậy, khi bộ phiên dịch xử lý mã nguồn này, nó sẽ tự động gán loại dữ liệu cho biến \emph{y} là một biến \emph{i32}.
Ngoài ra, nếu như bộ phiên dịch không rõ biến số nguyên là loại gì thì theo RFC 212 nó sẽ tự động gán cho là loại biến \emph{i32}.

\subsubsection{Enums}
Một \emph{enum} trong ngôn ngữ Rust có thể hiểu là một loại cấu trúc dữ liệu chứa một hoặc một số ít tập hợp các giá trị khác có thể xảy ra.
Khi sử dụng \emph{enum} của Rust, ta có thể xác định được rõ tất cả những kết quả có thể trả về, vì vậy đây là một công cu quan trọng và mạnh mẽ của Rust.
Ví dụ \ref{code:rust_enum_example} là một ví dụ cơ bản về một \emph{enum} được sử dụng rất rộng rãi trong thư viện chuẩn của Rust cũng như các thư viện bên ngoài.
\begin{listing}
\begin{rustcode}
pub enum Option<T> {
  Some(T),
  None,
}
\end{rustcode}
\caption{Ví dụ về một enum cơ bản}
\label{code:rust_enum_example}
\end{listing}

Có thể hiểu rằng, biến \emph{Option} khi trả về sẽ có thể có giá trị \emph{Some(T)} nào đó, hoặc là giá trị \emph{None}.
Nếu giá trị trả về là \emph{Some} thì theo định nghĩa nó sẽ chứa một giá trị kiểu \emph{T} nào đó.
Kiểu \emph{T} này có thể là bất kì loại dữ liệu nào được hỗ trợ bởi Rust, thậm chí là loại dữ liệu tùy chỉnh được khai báo bởi người lập trình.
Đây cũng là cách mà ngôn ngữ Rust định nghĩa các biến loại generic type.

Để sử dụng \emph{enum}, người lập trình phải sử dụng từ khóa \emph{match} (được giới thiệu ở phần \hyperref[pattern_matching]{pattern matching}) để giải quyết toàn bộ những giá trị có thể trả về.
Sử dụng cách này giúp xử lý toàn bộ những trường hợp có thể xảy ra.
Đây cũng là cách Rust đã giải quyết được một trong những vấn đề gây đau đầu cho các nhà phát triển phần mềm C/C++ đó là \emph{null-pointer} (con trỏ rỗng).

\subsubsection{Structs}
Một \emph{struct} trong ngôn ngữ Rust khá tương đồng với struct của ngôn ngữ C, nó là một cách giúp người lập trình có thể tạo ra một loại dữ liệu phức tạp hơn so với \emph{enum}.
Ta có thể kết hợp nhiều loại dữ liệu trong một \emph{struct} duy nhất, được xác định bởi tên của \emph{struct} đó.
Ví dụ \ref*{code:rust_struct_example} là ví dụ về một \emph{struct} có tên là \emph{Person}.

\begin{listing}
\begin{rustcode}
pub struct Person {
  pub name: String,
  pub age: u16,
  location: String,
}

impl Person {
  pub fn info(&self) {
    println!("{} is {} years old!", self.name, self.age)
  }
}
\end{rustcode}
\caption{Ví dụ về một struct có tên gọi là Person}
\label{code:rust_struct_example}
\end{listing}

Có thể dễ dàng nhận thấy sự tương đồng của một \emph{struct} của ngôn ngữ Rust với struct được sử dụng trong C.
Tuy nhiên, có một điều khác biệt lớn đó là mọi giá trị của \emph{struct} của Rust về mặc định đều là \emph{private}.
Để một hàm khác có thể sử dụng các giá trị này ta cần phải sử dụng từ khóa \emph{pub} để khai báo điều này một cách rõ ràng rằng đây là các giá trị \emph{public}.
Ngoài ra, ta còn có thể sử dụng từ khóa \emph{impl} để khai báo các hàm con cho \emph{struct} này như trong ví dụ trên, khá tương đồng với cách lập trình hướng đối tượng trong ngôn ngữ C++.

\subsubsection{Pointers}
Trong RCL, có hai loại pointers (con trỏ) được hỗ trợ, tuy nhiên cả hai đều là xét là \emph{unsafe} (xem thêm ở phần TODO).
Mặc dù cả hai loại con trỏ này được sử dụng khá rộng rãi khi tích hợp mã nguồn C chung với mã nguồn Rust trong cùng một chương trình nhưng trong phần lớn các trường hợp khác thì loại con trỏ này hoàn toàn không được sử dụng đến (trừ những trường hợp bắt buộc phải sử dụng mã \emph{unsafe}) vì trong thư viện lõi Rust đã cung cấp cho người dùng một abtraction layer để người lập trình có tương tác giữa dữ liệu và con trỏ của dữ liệu đó một cách dễ dàng.

\subsubsection{Slices}
\emph{Slice} trong Rust đơn giản là một cách để sử dụng một phần dữ liệu trong một array, thường được sử dụng để đọc một phần dữ liệu hay chỉnh sửa một số phần tử trong mảng đó.
Lưu ý rằng, chỉ khi mảng có tính mutable (khai báo bằng cách sử dụng từ khóa \emph{mut}) thì ta mới có thể chỉnh sửa được các giá trị trong mảng đó.
\emph{Slice} được kí hiệu bằng \emph{\&[T]}.
\begin{listing}
\begin{rustcode}
let x = &mut [1, 2, 3];
x[1] = 7; // lúc này mảng x sẽ có giá trị [7, 2, 3]
\end{rustcode}
\caption{Ví dụ về một slice đơn giản}
\label{code:rust_slice_vector_example}
\end{listing}

Ngoài ra, \emph{slice} cũng thường được sử dụng để chung với loại dữ liệu \emph{String} như một cách tiện lợi để đọc hay chỉnh sửa một phần dữ liệu đó.
Rust đặt tên cho cách sử dụng này là \emph{string slice}.
Ví dụ \ref{code:rust_string_slice} cho ta thấy một cách sử dụng đơn giản của một \emph{string slice}.
\begin{listing}
\begin{rustcode}
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
\end{rustcode}
\caption{Ví dụ về một string slice}
\label{code:rust_string_slice}
\end{listing}
\subsubsection{Giá trị Box}
Về mặc định, mọi giá trị khi khai báo trong Rust đều được cấp bộ nhớ trên \emph{stack}.
Ta có thể sử dụng \emph{box} để khai báo các biến này trên \emph{heap} bằng cách sử dụng cú pháp \emph{Box<T>}.
Một \emph{box} về cơ bản là một \emph{smart pointer} (con trỏ thông minh), trỏ đến vùng nhớ \emph{heap} có giá trị của kiểu \emph{T} cho trước.
Một khi giá trị \emph{box} không được sử dụng nữa (out of scope), thì giá trị của kiểu \emph{T} sẽ được xóa, và vùng nhớ heap trên được giải phóng.
Ví dụ \ref{code:rust_box_example} cho ta một ví dụ về cách sử dụng một giá trị \emph{box} cơ bản.

\begin{listing}
\begin{rustcode}
use std::mem;

struct Point {
    x: f64,
    y: f64,
}
fn boxed_origin() -> Box<Point> {
    // Khai báo điểm này trên heap, và trả về con trỏ của nó
    Box::new(Point { x: 0.0, y: 0.0 })
}
\end{rustcode}
\caption{Ví dụ về cách sử dụng một giá trị box}
\label{code:rust_box_example}
\end{listing}

\pagebreak
\subsubsection{Pattern matching}\label{pattern_matching}
\emph{Pattern matching} trong ngôn ngữ Rust khá tương đồng với cách sử dụng từ khóa \emph{switch} trong C.
Ta sử dụng từ khóa \emph{match} để xử lý toàn bộ các giá trị có thể trả về của một \emph{enum}.
Một điểm khác biệt của từ khóa \emph{match} so cách sử dụng \emph{switch} trong C đó là khi sử dụng \emph{match} ta phải xử lý toàn bộ tất cả các trường hợp, trong khi đó thì khi lập trình sử dụng \emph{switch} ta có thể bỏ qua một số trường hợp, ví dụ như ta có thể bỏ qua trường hợp \emph{default} mặc định.

Ta có thể sử dụng pattern matching để xử lý các giá trị của biến \emph{Option} như đã giới thiệu ở ví dụ \ref{code:rust_enum_example} như ví dụ \ref{code:rust_pattern_matching} sau:
\begin{listing}
\begin{rustcode}
let tmp: Option<u16> = Some(15);

match tmp {
  Some(number) => println!("The value is {}", number),
  None => (),
}
\end{rustcode}
\caption{Ví dụ về cách sử dụng pattern matching}
\label{code:rust_pattern_matching}
\end{listing}

\subsubsection{Traits}
Cách sử dụng của \emph{trait} trong Rust khá tương đồng với cách sử dụng \emph{Interface} trong Java đó là để tải sử dụng hoặc đa hình hóa (polymorphism) một phần mã đã viết trước đó.
Vì Rust là một ngôn ngữ hỗ trợ lối viết lập trình hàm (functional programming) nên khác với Java, một \emph{trait} không thể thừa kế (inherit) các hàm khác một cách trực tiếp mà nó đơn giản chỉ định nghĩa các hàm mà một object khác có thể tương tác với nó.
Ví dụ \ref{code:rust_trait_example} là một ví dụ cơ bản về cách sử dụng \emph{trait} trong Rust.
Người đọc có thể xem một ví dụ nâng cao khác về \emph{trait} trong phần phụ lục TODO.
\begin{listing}[ht]
\begin{rustcode}
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
\end{rustcode}
\caption{Ví dụ về cách sử dụng trait đơn giản}
\label{code:rust_trait_example}
\end{listing}

\subsubsection{Các loại vòng lặp}
Rust cung cấp hai loại vòng lặp cơ bản tương tự như C đó là vòng lặp \emph{for} và vòng lặp \emph{while}, ngoài ra còn có thêm vòng lặp \emph{loop} dành cho các thao tác lặp vĩnh viễn để tiện hơn cho việc lập trình.
Tuy nhiên, hoàn toàn khác với cấu trúc lặp \emph{for} của C là \mintinline[breaklines]{c}{for(initialize; condition; increment)} thì vòng lặp \emph{for} của Rust được sử dụng chung với các biến có kiểu có thể lặp được (iterator).
Ví dụ \ref{code:rust_loops} là ví dụ cơ bản về cách sử dụng hai vòng lặp cơ bản này.

\begin{center}
\begin{listing}
\begin{minipage}[ht]{0.4\linewidth}
\begin{rustcode}
fn main() {
    let mut number = 3;
    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }
    println!("Khởi động!!!");
}
\end{rustcode}
\end{minipage}
\qquad
\begin{minipage}[ht]{0.55\linewidth}
\begin{rustcode}
fn main() {
    let a = [5, 4, 3, 2, 1];
    for number in a.iter() {
        println!("the value is: {}", number);
    }
}
\end{rustcode}
\end{minipage}
\caption{Ví dụ về hai vòng lặp cơ bản của Rust}
\label{code:rust_loops}
\end{listing}
\end{center}

\subsubsection{Closures}
\emph{Closure} có thể hiểu đơn giản là một hàm ẩn danh (anonymous), được dùng để tạm thời giữ lại giá trị của một biến để rồi trở thành một argument (đối số) của một hàm khác.
Cách dùng \emph{closure} của Rust tương đối điển hình cho lối lập trình hàm nói chung, nó tương tự với cách sử dụng \emph{lamba} trong Python.
Ví dụ \ref{code:rust_closure_example} là cách sử dụng một \emph{closure} đơn giản.
\begin{listing}[H]
\begin{rustcode}
let a = 3;
let b = 4;
let line = |x| a*x + b;

println!("{} and {}", line(2), line(5)); // kết quả hiện ra màn hình là "10 and 19"
\end{rustcode}
\caption{Ví dụ về cách sử dụng closure đơn giản}
\label{code:rust_closure_example}
\end{listing}
